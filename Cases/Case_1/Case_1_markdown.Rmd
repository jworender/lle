---
title: "LLE: Case I"
author: "Jason Orender"
date: "2022-11-06"
output: 
  html_document: 
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(stringr, quietly = TRUE)
library(dplyr, quietly = TRUE)


```
## Introduction

This document was created by running the "Case_1_markdown.Rmd" file in RStudio.
It utilizes the script files "functions.R" and "rectify.R" within the "Code"
directory in this repository, which are used to define the functions that are
called below.  This document will create all of the synthetic data, fit the data
to a model, and then display the results.  Anyone interested is invited to clone
or fork the repository and change the settings for the purposes of 
self-demonstration. The verbiage here reflects the text in the paper, but in
some cases figures or examples that are present here were cut out of that
document in order to stay within a ten page limit.

## Generate the Data

The data generation script is in the file named "build_case_1_data.R".  It will
generate three data sets: 1) dset, 2) dset_train, and 3) dset_test.  The "dset"
object is a consolidated data set, and "dset_train" and "dset_test" objects are
mutually exclusive subsets of "dset".  This document can be run as a notebook,
block by block, or it can also be knitted into an html document if desired.

The "relevant" data is taken from curves 5, 8, 9, 10, 13, 25, and 30.  They are
marked "RELEVANT" in the chart title.  The plots generated from the next code
block show 40 different curves, only 7 of which contain relevant data.  The
others are added to obfuscate the data and make the task of picking out the
relevant features and time steps harder.  The red markers on the curves show
the time steps for which all of the criteria for an event are met.  Each time
step generates an example which includes the data from the ten time steps before.

The data generation script will produce a plot of the entire data set for each
feature over each time step.  There are a large number of these plots, but the
process for generation and the explanation of the results is located below.

```{r generate_data, echo=FALSE}
source("build_case_1_data.R")
```

## The data generation process

The following process is common to all of the synthetic data sets.

The simulated data was generated with the following requirements in mind:

1.	The data needed to be time-varying.  Each independent variable had a
    continuous stream of data that varied over time.  This was necessary to
    generate realistic scenarios that show the potential for analyzing lagged
    longitudinal data.
2.	The data needed to be range bound.  This reflected the desire to model
    realistic physical attributes, which tend to neither rise nor fall without
    end.
3.	The data needed to be complex.  In order to provide a convincing test, it
    needed to have no easily discernable pattern.
4.	The data needed to be cyclic.  Since the idea was to simulate sensor data or
    physical processes, and enough interactions needed to be generated in order
    to create a robust data set, some sort of cyclic process was necessary.

To meet these requirements, a sine function was chosen as the basic building
block for the simulated data.  Some additional details:

1.	When necessary, the Mersenne-Twister pseudorandom algorithm was used to
    generate pseudorandom numbers.  This is the default algorithm when
    generating pseudorandom numbers via the base R package.
2.	To generate complexity, multiple sine waves of varying frequency and
    amplitude were combined via superposition.
3.	The data was generated first, and then particular data streams were chosen
    and designated as the “relevant” features.
    
The procedure (the code is in the "build_case_1_data.R" script file):

1.	Generate a large number of sine waves with five possible randomly chosen
    frequencies per cycle.  Something like this was generated:  
    ![Curve Generation Step #1](../../Papers/Graphics/curve_generation_1.png)
2.  Superpose several of the curves generated in step 1.  Something like the
    curve next curve was generated by this step:  
    ![Curve Generation Step #2](../../Papers/Graphics/curve_generation_2.png)
3.	To create a diversity of values a new range was selected using a
    pseudorandom normal distribution centered on zero, standard deviation of
    0.05, and multiplied by 100. This produced a large enough diversity of
    magnitudes to demonstrate the range agnostic quality of the method.
4.	A version of the waves was shifted by a pre-determined amount to simulate
    lag.  The next graphic shows an example of this. Using lagged data simulates
    sensor data with readings that are time-late by an unknown amount, or an
    effect that has an unknown delay time between the change in reading and the
    occurrence of an event.   
    ![Curve Generation Step #3](../../Papers/Graphics/curve_generation_3.png)
5.	Assemble enough curves to have a large selection of potentially “relevant”
    and non-relevant curves.  Fig. 9 shows how the relevant curves are
    interpreted to generate events.  Note that the shifted curves determine when
    the event occurs, while the unshifted curves are matched with the time step
    in which they occurred to compose the data.  
    ![Curve Generation logical AND illustration](../../Papers/Graphics/curve_logical_AND.png)
6.	Each time step is interpreted as a separate example, and if all relevant
    curves meet the selection criteria during that time step, it is labeled as a
    “True” example, and otherwise is labeled as “False”.  The data for each
    example is taken from the unshifted curves.
7.	The data is next flattened such that a row contains the data from the
    current time step as well as the ten time steps previous (this is adjustable
    in the script).  The data from time steps zero (the current time step)
    through nine (the data nine time steps in the past) on the row for one
    example, for instance, will be the data for time steps one through ten on
    the next chronological example.  The next graphic illustrates:
    ![Curve Generation flatten](../../Papers/Graphics/curve_flatten.png)
8.	The final step is to randomize the rows to prevent any relationship between
    time steps from influencing the final outcome of the experiment.  There is
    no indication in the flattened data features where an example belongs
    chronologically with respect to the other examples.
9.	Once the data set has been created, it is split into training and testing
    sets with 70% of the data used for training and 30% of the data used for
    testing.

The procedure described generated a data set that included several relevant
features combined via a logical AND, is representative of what might be observed
with real sensor measurements and is complex enough to prevent any latent
patterns within the data from influencing the results.  The last example will
also illustrate what happens when a logical OR is introduced.

A data set with relevant features combined via a logical OR or a combination of
logical OR and logical AND will be generated in an identical way up to step 6.
Step 6 will be modified accordingly to generate the desired relationships among
the relevant variables.

```{r load_functions, echo=FALSE}
# Loading the functions that will be used to process the data - these are
# defined in a separate script file to allow re-use between markdown documents
# as well as create a set of generalized code that might be useful to others.
source("../../Code/functions.R")
source("../../Code/rectify.R")
```

## Plot the Results

The first case is a longitudinal data problem in which the following specific characteristics apply:

1.	7 relevant variables are intermixed with 33 non-relevant variables, all 7 of which must be within their relevant ranges to trigger an event.
2.	Each variable is tracked over 10 previous time-steps as well as the current time step (time step zero) and as a consequence generates 11 features per variable, for a total of 440 features per example in the flattened data.
3.	There is a single time-step/feature relevant for each variable.  As a result, the ratio of non-relevant to relevant features is approximately 63:1.  The time step features are meant to describe the delayed effect once the variable enters its critical range.
4.	There are 3437 examples in the training set, 530 of which are positive examples.
5.	There are 1474 examples in the test set, 232 of which are positive examples.  All test set examples are unseen until tested against the trained model and should be considered novel data.


```{r fit_models, echo=FALSE}
message("Detecting groups...")
data_struct <- organize(dset_train)
dset_groups <- data_struct$groups
message("  Done.")

# This code block uses a specialized routine called "modelfit" which is a
# generalized routine that fits data to a specified model type.  It was made
# to simplify the interface and make the code more succinct.
message("Fitting Models...")
# SQ means square rectified, which is a LASSO run on transformed data
cat("Fit SQ");timestamp()
model_1 <- modelfit(data = dset_train, fit_type = "SQ", groups = dset_groups,
                params = list(sdfilter = NULL))
# LS just means LASSO
cat("Fit LS");timestamp()
model_2 <- modelfit(data = dset_train, fit_type = "LS", groups = dset_groups)
timestamp()
message("  Done.")
```
The next plots, which show the results of the model fit plotted against the
training and then the test set, tells a very straightforward story.  The
resultant model describes the data extremely well when the data is transformed
into a binary format using the previous procedure.  

```{r transformed_data_plots, echo=FALSE}
hpos <- 0.4
message("Plotting transformed data examples...")
plot(model_1, title = "Case #1 Training Set", h=.5, cx = hpos,
     ylab = "Predicted Probability")
plot(model_1, title = "Case #1 Test Set", data = dset_test, h=.5, cx = hpos,
     ylab = "Predicted Probability")
message("  Done.")
```

If the transformation is not used, the next plot shows the resultant LASSO fit
on the un-transformed data.  Without the transformation, the LASSO fit severely
underperforms with respect to the fit performed with the transformed data. In
addition, the computational power required to calculate the fit on the un-
transformed data is significantly greater.  The LASSO fit on the un-transformed
data took nearly double (1.83x) the amount of time required to both transform
the data and then perform the fit in the transformed data case
(single-threaded). Once the data is transformed, the remainder of the
calculations are nearly all integer math until the final coefficients are
calculated. This could prove a significant advantage when applied in a high
performance computing (HPC) setting.

```{r untransformed_data_plots, echo=FALSE}
message("Plotting un-transformed data examples...")
plot(model_2, title = "Case #1 Training Set (LASSO no transformation)", h=.5,
     ylab = "Predicted Probability", cx = hpos)
plot(model_2, title = "Case #1 Test Set (LASSO no transformation)",
     ylab = "Predicted Probability", data = dset_test, h=.5, cx = hpos)
message("  Done.")
```
The reason that LASSO was chosen for the discrimination algorithm is that it by
its very nature produces sparse feature sets.  For the sake of completeness,
however, here are a few alternate modeling schemes (bearing in mind that this is
the absolute simplest case submitted for review).

A decision-tree algorithm should theoretically do well with this data, but one
of the major disadvantages to these model types is overfitting to non-relevant
data and the excessive computational load required for large data sets.  This
training data set consists of 3,437 examples, which is not large and may be
considered small in some contexts, yet the fitting for Random Forest took 86
seconds, while on the same machine fitting the LASSO to the square-rectified
data (including the process of rectifying the data) took about two seconds.  The
results are superior to the standard LASSO performed on un-transformed data, but
still fall short of the LASSO performed on the transformed data.

Fitting a Random Forest model to a rectified version of the data, as might be
expected, yields a better fit.  However, the performance of the Random Forest
fit is still inferior to that of the LASSO fit on transformed data, and the
fitting process took a considerably longer 25 seconds on the same machine as the
other two runs (which puts it at ~10x the execution time of the LASSO).

```{r}
message("Fitting Random Forest model...")
timestamp()
model_rf <- modelfit(data = dset_train, fit_type = "RF", groups = dset_groups)
timestamp()
message("  Done.")
message("Plotting un-transformed data examples...")
plot(model_rf, title = "Case #1 Training Set (Random Forest no transformation)", h=.5,
     ylab = "Predicted Probability", cx = hpos)
plot(model_rf, title = "Case #1 Test Set (Random Forest no transformation)",
     ylab = "Predicted Probability", data = dset_test, h=.5, cx = hpos)
message("  Done.")
```
```{r}
timestamp()
dset_train_SQ <- rectify(dset_train, groups = dset_groups)
dset_test_SQ  <- rectify(dset_test, groups = dset_groups,
                         limits = dset_train_SQ$limits)
model_rf <- modelfit(data = dset_train_SQ$data, fit_type = "RF", groups = dset_groups)
timestamp()
message("  Done.")
message("Plotting transformed data examples...")
plot(model_rf, title = "Case #1 Training Set (Random Forest with transformation)",
     h=.5, ylab = "Predicted Probability", cx = hpos)
plot(model_rf, title = "Case #1 Test Set (Random Forest with transformation)",
     ylab = "Predicted Probability", data = dset_test_SQ$data, h=.5, cx = hpos)

```
As mentioned in the paper, the group lasso was also intended to fit categorical
variables using data sets which have features that are related or dependent.
As seen below, however, the results on this particular type of problem are
actually worse than even just a standard LASSO by a large margin.  In addition,
the fitting process itself took 107 seconds on the same hardware used to
benchmark the other methods, which is considerably longer than *any* of the
other methods.  The transformed data  results also have a peculiar and irregular
shape when compared to the other methods (fitting the transformed data took
about 49 seconds on the same hardware).

```{r}
message("Fitting Group LASSO model...")
timestamp()
model_gl <- modelfit(data = dset_train, fit_type = "GL", groups = dset_groups)
timestamp()
message("  Done.")
message("Plotting un-transformed data examples...")
plot(model_gl, title = "Case #1 Training Set (Group LASSO no transformation)", h=.5,
     ylab = "Predicted Probability", cx = hpos)
plot(model_gl, title = "Case #1 Test Set (Group LASSO no transformation)",
     ylab = "Predicted Probability", data = dset_test, h=.5, cx = hpos)
timestamp()
message("  Done.")
```

```{r}
timestamp()
# rectifying again to show an accurate time estimate which includes rectification
dset_train_SQ <- rectify(dset_train, groups = dset_groups)
dset_test_SQ  <- rectify(dset_test, groups = dset_groups,
                         limits = dset_train_SQ$limits)
model_gl <- modelfit(data = dset_train_SQ$data, fit_type = "GL", groups = dset_groups)
timestamp()
message("  Done.")
message("Plotting transformed data examples...")
plot(model_gl, title = "Case #1 Training Set (Group LASSO with transformation)", h=.5,
     ylab = "Predicted Probability", cx = hpos)
plot(model_gl, title = "Case #1 Test Set (Group LASSO with transformation)",
     ylab = "Predicted Probability", data = dset_test_SQ$data, h=.5, cx = hpos)

```

Another common choice in a situation like this with a large number of highly
correlated features is the Ridge Regression method.  In practice, these methods
produce almost the same results on this data, except that it misidentified the
correct time step on one of the weaker features (a feature that only affected
the outcome of a handful of examples and was not required to fully describe any
outcomes).  The time it took was comparable as well (~2 seconds using the same
hardware as above).  In the future, it may be advantageous to use Ridge
Regression as an alternative with nearly the same fidelity since it has a
closed form solution and may be easier to parallelize for use with high
performance computation hardware. Comparing the two sets of plots, they look
very similar but there are a few differentiating details.

```{r}
message("Fitting Ridge Regression model...")
timestamp()
model_rr <- modelfit(data = dset_train, fit_type = "RR", groups = dset_groups)
timestamp()
message("  Done.")
message("Plotting un-transformed data examples...")
plot(model_rr, title = "Case #1 Training Set (Ridge Regression no transformation)",
     h=.5, ylab = "Predicted Probability", cx = hpos)
plot(model_rr, title = "Case #1 Test Set (Ridge Regression no transformation)",
     data = dset_test, h=.5, cx = hpos, ylab = "Predicted Probability")
message("  Done.")
```
```{r}
timestamp()
dset_train_SQ <- rectify(dset_train, groups = dset_groups)
dset_test_SQ  <- rectify(dset_test, groups = dset_groups,
                         limits = dset_train_SQ$limits)
model_rr <- modelfit(data = dset_train_SQ$data, fit_type = "RR", groups = dset_groups)
timestamp()
message("  Done.")
message("Plotting transformed data examples...")
plot(model_rr, title = "Case #1 Training Set (Ridge Regression with transformation)",
     h=.5, ylab = "Predicted Probability", cx = hpos)
plot(model_rr, title = "Case #1 Test Set (Ridge Regression with transformation)",
     data = dset_test_SQ$data, h=.5, cx = hpos, ylab = "Predicted Probability")

```

The advantages of the transformation procedure go beyond the accuracy of the
results and the reduced computational power.  The precision with which it can
pinpoint the precise features required for the sparse solution means that in a
longitudinal data scenario such as this, both the variable and the specific lag
for each variable can potentially be derived.  The bar plot below shows the
coefficients calculated for the LASSO applied to the transformed data.  The
sparseness of the solution is almost ideal; there are only five spurious returns
and three of those were directly adjacent to the correct return.

```{r transformed_data_barplot, echo=FALSE}
TRANS   <- 0.2
BARHT   <- 7.5
beta1   <- model_1$model$beta[,]
markers <- rep(0,length(beta1))
cols    <- rep(rgb(0,0,0,0), length(beta1))

cols[grep("V5TM10", names(beta1))]     <- rgb(1.0, 0.0, 0.0,TRANS) #RED
markers[grep("V5TM10", names(beta1))]  <- BARHT
cols[grep("V8TM10", names(beta1))]     <- rgb(0.5, 0.0, 0.5,TRANS) #PURPLE
markers[grep("V8TM10", names(beta1))]  <- BARHT
cols[grep("V9TM1$", names(beta1))]      <- rgb(0.0, 1.0, 0.0,TRANS) #GREEN
markers[grep("V9TM1$", names(beta1))]   <- BARHT
cols[grep("V10TM0", names(beta1))]     <- rgb(1.0, 0.5, 0.0,TRANS) #ORANGE
markers[grep("V10TM0", names(beta1))]  <- BARHT
cols[grep("V13TM2", names(beta1))]     <- rgb(1.0, 0.0, 1.0,TRANS) #MAGENTA
markers[grep("V13TM2", names(beta1))]  <- BARHT
cols[grep("V25TM3", names(beta1))]     <- rgb(0.1, 0.5, 0.5,TRANS) #TEAL
markers[grep("V25TM3", names(beta1))]  <- BARHT
cols[grep("V30TM7", names(beta1))]     <- rgb(0.1, 0.1, 0.0,TRANS) #DARK BROWN
markers[grep("V30TM7", names(beta1))]  <- BARHT

par(new=FALSE, mar = c(6,3,3,2))
barplot(beta1, border = "blue", col = "blue", ylim = c(-0.5, BARHT), las = 2,
        xaxt = "n")

par(new=TRUE)
bplot <- barplot(markers, border = cols, col = cols, ylim = c(-0.5, BARHT),
                 yaxt = "n", main = "Coefficient Magnitudes for Transformed Data Fit")
cnames <- c("V5TM10", "V8TM10", "V9TM1", "V10TM0", "V13TM2", "V25TM3", "V30TM7")
bplot_at <- NULL
for (i in 1:length(cnames))
  bplot_at <- c(bplot_at,grep(paste0(cnames[i],"$"),names(beta1)))
bplot_labels <- rep(NA, length(beta1))
bplot_labels[bplot_at] <- cnames
axis(1, at = bplot, labels =bplot_labels, las=2, cex.axis=0.7, tick=FALSE)
```

This can be contrasted with the LASSO solution on the un-transformed data in
the following plot.  The scattershot arrangement of the coefficient magnitudes
clearly reveals why the solution shown above for the un-transformed data so
greatly underperforms.

```{r untransformed_data_barplot, echo=FALSE}
BARHT   <- 30
beta2   <- model_2$model$beta[,]
markers <- rep(0,length(beta2))
cols    <- rep(rgb(0,0,0,0), length(beta2))
  
cols[grep("V5TM10", names(beta2))]     <- rgb(1.0, 0.0, 0.0,TRANS) #RED
markers[grep("V5TM10", names(beta2))]  <- BARHT
cols[grep("V8TM10", names(beta2))]     <- rgb(0.5, 0.0, 0.5,TRANS) #PURPLE
markers[grep("V8TM10", names(beta2))]  <- BARHT
cols[grep("V9TM1", names(beta2))]      <- rgb(0.0, 1.0, 0.0,TRANS) #GREEN
markers[grep("V9TM1", names(beta2))]   <- BARHT
cols[grep("V10TM0", names(beta2))]     <- rgb(1.0, 0.5, 0.0,TRANS) #ORANGE
markers[grep("V10TM0", names(beta2))]  <- BARHT
cols[grep("V13TM2", names(beta2))]     <- rgb(1.0, 0.0, 1.0,TRANS) #MAGENTA
markers[grep("V13TM2", names(beta2))]  <- BARHT
cols[grep("V25TM3", names(beta2))]     <- rgb(0.1, 0.5, 0.5,TRANS) #TEAL
markers[grep("V25TM3", names(beta2))]  <- BARHT
cols[grep("V30TM7", names(beta2))]     <- rgb(0.1, 0.1, 0.0,TRANS) #DARK BROWN
markers[grep("V30TM7", names(beta2))]  <- BARHT
  
par(new=FALSE, mar = c(6,3,3,2))
barplot(beta2, border = "blue", col = "blue", ylim = c(-30, BARHT), las = 2,
        xaxt = "n")

par(new=TRUE)
bplot <- barplot(markers, border = cols, col = cols, ylim = c(-0.5, BARHT),
                 yaxt = "n", main = "Coefficient Magnitudes for Un-Transformed Data Fit")
cnames <- c("V5TM10", "V8TM10", "V9TM1", "V10TM0", "V13TM2", "V25TM3", "V30TM7")
bplot_at <- NULL
for (i in 1:length(cnames))
  bplot_at <- c(bplot_at,grep(paste0(cnames[i],"$"),names(beta1)))
bplot_labels <- rep(NA, length(beta1))
bplot_labels[bplot_at] <- cnames
axis(1, at = bplot, labels =bplot_labels, las=2, cex.axis=0.7, tick=FALSE)
```

